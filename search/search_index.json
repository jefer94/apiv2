{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting started Working inside Docker (slower) Build BreatheCode Dev docker image Instal docker desktop in you use Windows else find a guide to install Docker and Docker Compose in your linux distribution uname -a . # Check which dependencies you need install in you operating system python -m scripts.doctor # Generate the BreatheCode Dev docker image docker-compose build bc-dev Testing inside BreatheCode Dev # Open the BreatheCode Dev, this shell don't export the port 8000 docker-compose run bc-dev fish # Testing pipenv run test ./breathecode/activity # path # Coverage pipenv run cov breathecode.activity # python module path Run BreatheCode API as docker service # open BreatheCode API as a service and export the port 8000 docker-compose up -d bc-dev # open the BreatheCode Dev, this shell don't export the port 8000 docker-compose run bc-dev fish # create super user pipenv run python manage.py createsuperuser # Close the BreatheCode Dev exit # See the output of Django docker-compose logs -f bc-dev # open localhost:8000 to view the api # open localhost:8000/admin to view the admin Working in your local machine (recomended) Installation in your local machine Instal docker desktop in you use Windows else find a guide to install Docker and Docker Compose in your linux distribution uname -a . # Check which dependencies you need install in you operating system python -m scripts.doctor # Setting up the redis and postgres database, you also can install manually in your local machine this databases docker-compose up -d redis postgres # Install and setting up your development environment (this command replace your .env file) python -m scripts.install Testing in your local machine # Testing pipenv run test ./breathecode/activity # path # Coverage pipenv run cov breathecode.activity # python module path Run BreatheCode API in your local machine # Collect statics pipenv run python manage.py collectstatic --noinput # Run migrations pipenv run python manage.py migrate # Load fixtures (populate the database) pipenv run python manage.py loaddata breathecode/*/fixtures/dev_*.json # Create super user pipenv run python manage.py createsuperuser # Run server pipenv run start # open localhost:8000 to view the api # open localhost:8000/admin to view the admin","title":"Getting started"},{"location":"#getting-started","text":"","title":"Getting started"},{"location":"#working-inside-docker-slower","text":"","title":"Working inside Docker (slower)"},{"location":"#build-breathecode-dev-docker-image","text":"Instal docker desktop in you use Windows else find a guide to install Docker and Docker Compose in your linux distribution uname -a . # Check which dependencies you need install in you operating system python -m scripts.doctor # Generate the BreatheCode Dev docker image docker-compose build bc-dev","title":"Build BreatheCode Dev docker image"},{"location":"#testing-inside-breathecode-dev","text":"# Open the BreatheCode Dev, this shell don't export the port 8000 docker-compose run bc-dev fish # Testing pipenv run test ./breathecode/activity # path # Coverage pipenv run cov breathecode.activity # python module path","title":"Testing inside BreatheCode Dev"},{"location":"#run-breathecode-api-as-docker-service","text":"# open BreatheCode API as a service and export the port 8000 docker-compose up -d bc-dev # open the BreatheCode Dev, this shell don't export the port 8000 docker-compose run bc-dev fish # create super user pipenv run python manage.py createsuperuser # Close the BreatheCode Dev exit # See the output of Django docker-compose logs -f bc-dev # open localhost:8000 to view the api # open localhost:8000/admin to view the admin","title":"Run BreatheCode API as docker service"},{"location":"#working-in-your-local-machine-recomended","text":"","title":"Working in your local machine (recomended)"},{"location":"#installation-in-your-local-machine","text":"Instal docker desktop in you use Windows else find a guide to install Docker and Docker Compose in your linux distribution uname -a . # Check which dependencies you need install in you operating system python -m scripts.doctor # Setting up the redis and postgres database, you also can install manually in your local machine this databases docker-compose up -d redis postgres # Install and setting up your development environment (this command replace your .env file) python -m scripts.install","title":"Installation in your local machine"},{"location":"#testing-in-your-local-machine","text":"# Testing pipenv run test ./breathecode/activity # path # Coverage pipenv run cov breathecode.activity # python module path","title":"Testing in your local machine"},{"location":"#run-breathecode-api-in-your-local-machine","text":"# Collect statics pipenv run python manage.py collectstatic --noinput # Run migrations pipenv run python manage.py migrate # Load fixtures (populate the database) pipenv run python manage.py loaddata breathecode/*/fixtures/dev_*.json # Create super user pipenv run python manage.py createsuperuser # Run server pipenv run start # open localhost:8000 to view the api # open localhost:8000/admin to view the admin","title":"Run BreatheCode API in your local machine"},{"location":"breathecode-api/","text":"BreatheCode API Postman OpenApi","title":"BreatheCode API"},{"location":"breathecode-api/#breathecode-api","text":"Postman OpenApi","title":"BreatheCode API"},{"location":"capabilities/","text":"BreatheCode Capabilities Authenticated users must belong to at least one academy with a specific role, each role has a series of capabilities that specify what any user with that role will be \"capable\" of doing. Authenticated methods must be decorated with the @capable_of decorator in increase security validation. For example: from breathecode.utils import capable_of @capable_of('crud_member') def post(self, request, academy_id=None): serializer = StaffPOSTSerializer(data=request.data) if serializer.is_valid(): serializer.save() return Response(serializer.data, status=status.HTTP_201_CREATED) return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST) Any view decorated with the @capable_of must be used passing an academy id either: Anywhere on the endpoint url, E.g: path('academy/<int:academy_id>/member', MemberView.as_view()), Or on the request header using the Academy header. Available capabilities: This list is alive, it will grow and vary overe time: slug description read_members Allows reading the list of academy members crud_members Allows creating, deleting and updating academy members","title":"BreatheCode Capabilities"},{"location":"capabilities/#breathecode-capabilities","text":"Authenticated users must belong to at least one academy with a specific role, each role has a series of capabilities that specify what any user with that role will be \"capable\" of doing. Authenticated methods must be decorated with the @capable_of decorator in increase security validation. For example: from breathecode.utils import capable_of @capable_of('crud_member') def post(self, request, academy_id=None): serializer = StaffPOSTSerializer(data=request.data) if serializer.is_valid(): serializer.save() return Response(serializer.data, status=status.HTTP_201_CREATED) return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST) Any view decorated with the @capable_of must be used passing an academy id either: Anywhere on the endpoint url, E.g: path('academy/<int:academy_id>/member', MemberView.as_view()), Or on the request header using the Academy header.","title":"BreatheCode Capabilities"},{"location":"capabilities/#available-capabilities","text":"This list is alive, it will grow and vary overe time: slug description read_members Allows reading the list of academy members crud_members Allows creating, deleting and updating academy members","title":"Available capabilities:"},{"location":"configuring-the-github-secrets/","text":"Configuring the Github secrets Get Dockerhub token Add the repo to Coveralls https://coveralls.io/repos/new Add the repo to Codecov https://app.codecov.io/gh/+ Set up the secrets","title":"Configuring the Github secrets"},{"location":"configuring-the-github-secrets/#configuring-the-github-secrets","text":"Get Dockerhub token Add the repo to Coveralls https://coveralls.io/repos/new Add the repo to Codecov https://app.codecov.io/gh/+ Set up the secrets","title":"Configuring the Github secrets"},{"location":"editor-configs/","text":"Enable formatter in Visual Studio Code Run python -m scripts.install .","title":"Enable formatter in Visual Studio Code"},{"location":"editor-configs/#enable-formatter-in-visual-studio-code","text":"Run python -m scripts.install .","title":"Enable formatter in Visual Studio Code"},{"location":"fixtures/","text":"Fixtures Fixtures are fake data ideal for development. Saving new fixtures python manage.py dumpdata auth > ./breathecode/authenticate/fixtures/users.json Loading all fixtures pipenv run python manage.py loaddata breathecode/*/fixtures/dev_*.json","title":"Fixtures"},{"location":"fixtures/#fixtures","text":"Fixtures are fake data ideal for development.","title":"Fixtures"},{"location":"fixtures/#saving-new-fixtures","text":"python manage.py dumpdata auth > ./breathecode/authenticate/fixtures/users.json","title":"Saving new fixtures"},{"location":"fixtures/#loading-all-fixtures","text":"pipenv run python manage.py loaddata breathecode/*/fixtures/dev_*.json","title":"Loading all fixtures"},{"location":"google-cloud-functions/","text":"Google Cloud Functions Write a HTTP function https://cloud.google.com/functions/docs/writing/http See active functions https://console.cloud.google.com/functions/list?project=breathecode-197918&_ga=2.252299017.106570839.1625533908-188955223.1618985878 Testing function https://cloud.google.com/functions/docs/testing/test-http#functions-testing-http-integration-python List functions Name Activator Resource Repository process-zap HTTP process-zap screenshots HTTP screenshots jefer94/screenshots resize-image HTTP resize-image breatheco-de/gcloud-resize-image thumbnail-generator Bucket media-breathecode breatheco-de/gcloud-thumbnail-generator thumbnail-generator-dev Bucket media-breathecode-dev breatheco-de/gcloud-thumbnail-generator","title":"Google Cloud Functions"},{"location":"google-cloud-functions/#google-cloud-functions","text":"","title":"Google Cloud Functions"},{"location":"google-cloud-functions/#write-a-http-function","text":"https://cloud.google.com/functions/docs/writing/http","title":"Write a HTTP function"},{"location":"google-cloud-functions/#see-active-functions","text":"https://console.cloud.google.com/functions/list?project=breathecode-197918&_ga=2.252299017.106570839.1625533908-188955223.1618985878","title":"See active functions"},{"location":"google-cloud-functions/#testing-function","text":"https://cloud.google.com/functions/docs/testing/test-http#functions-testing-http-integration-python","title":"Testing function"},{"location":"google-cloud-functions/#list-functions","text":"Name Activator Resource Repository process-zap HTTP process-zap screenshots HTTP screenshots jefer94/screenshots resize-image HTTP resize-image breatheco-de/gcloud-resize-image thumbnail-generator Bucket media-breathecode breatheco-de/gcloud-thumbnail-generator thumbnail-generator-dev Bucket media-breathecode-dev breatheco-de/gcloud-thumbnail-generator","title":"List functions"},{"location":"icons/","text":"Icons The following icons are being used for the slack integrations https://www.pngrepo.com/collection/soft-colored-ui-icons/1","title":"Icons"},{"location":"icons/#icons","text":"The following icons are being used for the slack integrations https://www.pngrepo.com/collection/soft-colored-ui-icons/1","title":"Icons"},{"location":"signals/","text":"Signals There is a new signals.py and receivers.py logic available to every app. Basically we can create \"events\" (a.k.a: signals) that are emited when something of interest happens withing any app, then, any other application can start \"listening\" (a.k.a receiving) to that event and do something about it (similar to the side-effect concept in react.useEffect). Let's say we want other applications to be notified when a user accepts a new invite, the first we need to do is create a custom signal on the breathecode.authenticate app: # signals.py from django import dispatch invite_accepted = dispatch.Signal(providing_args=[\"task_id\"]) Once the signal is registered we need to dispatch it when a user accepts an invite, I decided to add that logice inside the breathecode.authenticate.models.ProfileAcademy.save() method, we know for sure that when the ProfileAcademy.status changes from INVITED to ACTIVE it means that one invite has ben accepted. Here is the code of the save method . # breathecode.authenticate.models.ProfileAcademy class ProfileAcademy(models.Model): ... def save(self, *args, **kwargs): if self.__old_status != self.status and self.status == 'ACTIVE': invite_accepted.send(instance=self, sender=ProfileAcademy) super().save(*args, **kwargs) # Call the \"real\" save() method. Now that the triggering of the signal is implemented we can make sure any previous breathecode.marketing.models.FormEntry's can be connected to the new user that accepted the invite. We can do that by [implementing a receiver](https://github.com/breatheco-de/apiv2/blob/master/breathecode/marketing/receivers.py#L11) for that inside the receiver.py` inside the marketing app: # breathecode.marketing.receivers.py from django.dispatch import receiver from breathecode.authenticate.signals import invite_accepted from breathecode.authenticate.models import ProfileAcademy from .models import FormEntry @receiver(invite_accepted, sender=ProfileAcademy) def post_save_profileacademy(sender, instance, **kwargs): # if a new ProfileAcademy is created on the authanticate app # look for the email on the formentry list and bind it entries = FormEntry.objects.filter(email=instance.user.email, user__isnull=True) for entry in entries: entry.user = instance.user entry.save()","title":"Signals"},{"location":"signals/#signals","text":"There is a new signals.py and receivers.py logic available to every app. Basically we can create \"events\" (a.k.a: signals) that are emited when something of interest happens withing any app, then, any other application can start \"listening\" (a.k.a receiving) to that event and do something about it (similar to the side-effect concept in react.useEffect). Let's say we want other applications to be notified when a user accepts a new invite, the first we need to do is create a custom signal on the breathecode.authenticate app: # signals.py from django import dispatch invite_accepted = dispatch.Signal(providing_args=[\"task_id\"]) Once the signal is registered we need to dispatch it when a user accepts an invite, I decided to add that logice inside the breathecode.authenticate.models.ProfileAcademy.save() method, we know for sure that when the ProfileAcademy.status changes from INVITED to ACTIVE it means that one invite has ben accepted. Here is the code of the save method . # breathecode.authenticate.models.ProfileAcademy class ProfileAcademy(models.Model): ... def save(self, *args, **kwargs): if self.__old_status != self.status and self.status == 'ACTIVE': invite_accepted.send(instance=self, sender=ProfileAcademy) super().save(*args, **kwargs) # Call the \"real\" save() method. Now that the triggering of the signal is implemented we can make sure any previous breathecode.marketing.models.FormEntry's can be connected to the new user that accepted the invite. We can do that by [implementing a receiver](https://github.com/breatheco-de/apiv2/blob/master/breathecode/marketing/receivers.py#L11) for that inside the receiver.py` inside the marketing app: # breathecode.marketing.receivers.py from django.dispatch import receiver from breathecode.authenticate.signals import invite_accepted from breathecode.authenticate.models import ProfileAcademy from .models import FormEntry @receiver(invite_accepted, sender=ProfileAcademy) def post_save_profileacademy(sender, instance, **kwargs): # if a new ProfileAcademy is created on the authanticate app # look for the email on the formentry list and bind it entries = FormEntry.objects.filter(email=instance.user.email, user__isnull=True) for entry in entries: entry.user = instance.user entry.save()","title":"Signals"},{"location":"testing/","text":"Testing Run tests pipenv run test ./breathecode/ Run coverage pipenv run cov breathecode Testing inside Docker (fallback option) Check which dependencies you need install in you operating system pipenv run doctor or python -m scripts.doctor . Instal docker desktop in you use Windows else find a guide to install Docker and Docker Compose in your linux distribution uname -a . Generate the BreatheCode Shell image with pipenv run docker_build_shell . Run BreatheCode Shell with docker-compose run bc-shell Run pipenv run test or pipenv run cov .","title":"Testing"},{"location":"testing/#testing","text":"","title":"Testing"},{"location":"testing/#run-tests","text":"pipenv run test ./breathecode/","title":"Run tests"},{"location":"testing/#run-coverage","text":"pipenv run cov breathecode","title":"Run coverage"},{"location":"testing/#testing-inside-docker-fallback-option","text":"Check which dependencies you need install in you operating system pipenv run doctor or python -m scripts.doctor . Instal docker desktop in you use Windows else find a guide to install Docker and Docker Compose in your linux distribution uname -a . Generate the BreatheCode Shell image with pipenv run docker_build_shell . Run BreatheCode Shell with docker-compose run bc-shell Run pipenv run test or pipenv run cov .","title":"Testing inside Docker (fallback option)"},{"location":"apps/activities/","text":"Activity API This API uses Google DataStore as storage, there is not local storage on Heroku or Postgress. We need Google DataStore because we plan to store hugh amounts of activities that the user can do inside breathecode. Possible activities (so far): \"breathecode_login\" //every time it logs in \"online_platform_registration\" //first day using breathecode \"public_event_attendance\" //attendy on an eventbrite event \"classroom_attendance\" //when the student attent to class \"classroom_unattendance\" //when the student miss class \"lesson_opened\" //when a lessons is opened on the platform \"office_attendance\" //when the office raspberry pi detects the student \"nps_survey_answered\" //when a nps survey is answered by the student \"exercise_success\" //when student successfuly tests exercise Any activity has the following inputs: 'cohort', 'data', 'day', 'slug', 'user_agent', Endpoints for the user Get recent user activity GET: activity/user/{email_or_id}?slug=activity_slug Add a new user activity (requiers autentication) POST: activity/user/{email_or_id} { 'slug' => 'activity_slug', 'data' => 'any aditional data (string or json-encoded-string)' } \ud83d\udca1 Node: You can pass the cohort in the data json object and it will be possible to filter on the activity graph like this: { 'slug' => 'activity_slug', 'data' => \"{ \\\"cohort\\\": \\\"mdc-iii\\\" }\" (json encoded string with the cohort id) } Endpoints for the Cohort Get recent user activity GET: activity/cohort/{slug_or_id}?slug=activity_slug Endpoints for the coding_error's Get recent user coding_errors GET: activity/coding_error/{email_or_id}?slug=activity_slug Add a new coding_error (requiers autentication) POST: activity/coding_error/ { \"user_id\" => \"my@email.com\", \"slug\" => \"webpack_error\", \"data\" => \"optiona additional information about the error\", \"message\" => \"file not found\", \"name\" => \"module-not-found, \"severity\" => \"900\", \"details\" => \"stack trace for the error as string\" }","title":"Activities"},{"location":"apps/activities/#activity-api","text":"This API uses Google DataStore as storage, there is not local storage on Heroku or Postgress. We need Google DataStore because we plan to store hugh amounts of activities that the user can do inside breathecode. Possible activities (so far): \"breathecode_login\" //every time it logs in \"online_platform_registration\" //first day using breathecode \"public_event_attendance\" //attendy on an eventbrite event \"classroom_attendance\" //when the student attent to class \"classroom_unattendance\" //when the student miss class \"lesson_opened\" //when a lessons is opened on the platform \"office_attendance\" //when the office raspberry pi detects the student \"nps_survey_answered\" //when a nps survey is answered by the student \"exercise_success\" //when student successfuly tests exercise Any activity has the following inputs: 'cohort', 'data', 'day', 'slug', 'user_agent',","title":"Activity API"},{"location":"apps/activities/#endpoints-for-the-user","text":"Get recent user activity GET: activity/user/{email_or_id}?slug=activity_slug Add a new user activity (requiers autentication) POST: activity/user/{email_or_id} { 'slug' => 'activity_slug', 'data' => 'any aditional data (string or json-encoded-string)' } \ud83d\udca1 Node: You can pass the cohort in the data json object and it will be possible to filter on the activity graph like this: { 'slug' => 'activity_slug', 'data' => \"{ \\\"cohort\\\": \\\"mdc-iii\\\" }\" (json encoded string with the cohort id) } Endpoints for the Cohort Get recent user activity GET: activity/cohort/{slug_or_id}?slug=activity_slug Endpoints for the coding_error's Get recent user coding_errors GET: activity/coding_error/{email_or_id}?slug=activity_slug Add a new coding_error (requiers autentication) POST: activity/coding_error/ { \"user_id\" => \"my@email.com\", \"slug\" => \"webpack_error\", \"data\" => \"optiona additional information about the error\", \"message\" => \"file not found\", \"name\" => \"module-not-found, \"severity\" => \"900\", \"details\" => \"stack trace for the error as string\" }","title":"Endpoints for the user"},{"location":"apps/admissions/","text":"BreatheCode.Admissions This module take care of the academic side of breathecode: Students, Cohorts, Course (aka: Certificate), Syllabus, etc. These are some of the things you can do with the breathecode.admissions API: Manage Academies (BreatheCode let's you divide the academic operations into several academies normally based on territory, for example: 4Geeks Academy Miami vs 4Geeks Academy Madrid). Manage Academy Staff: There are multiple roles surroing an academy, here you can invite users to one or many academies and assign them roles based on their responsabilities. Manage Students (invite and delete students). Manage Cohorts: Every new batch of students that starts in a classroom with a start and end date is called a \"Cohort\". TODO: finish this documentation. Commands Sync academies python manage.py sync_admissions academies Override previous academies python manage.py sync_admissions academies --override Sync courses python manage.py sync_admissions certificates Sync cohorts python manage.py sync_admissions cohorts Sync students python manage.py sync_admissions students --limit=3 Limit: the number of students to sync","title":"BreatheCode.Admissions"},{"location":"apps/admissions/#breathecodeadmissions","text":"This module take care of the academic side of breathecode: Students, Cohorts, Course (aka: Certificate), Syllabus, etc. These are some of the things you can do with the breathecode.admissions API: Manage Academies (BreatheCode let's you divide the academic operations into several academies normally based on territory, for example: 4Geeks Academy Miami vs 4Geeks Academy Madrid). Manage Academy Staff: There are multiple roles surroing an academy, here you can invite users to one or many academies and assign them roles based on their responsabilities. Manage Students (invite and delete students). Manage Cohorts: Every new batch of students that starts in a classroom with a start and end date is called a \"Cohort\". TODO: finish this documentation.","title":"BreatheCode.Admissions"},{"location":"apps/admissions/#commands","text":"","title":"Commands"},{"location":"apps/admissions/#sync-academies","text":"python manage.py sync_admissions academies Override previous academies python manage.py sync_admissions academies --override","title":"Sync academies"},{"location":"apps/admissions/#sync-courses","text":"python manage.py sync_admissions certificates","title":"Sync courses"},{"location":"apps/admissions/#sync-cohorts","text":"python manage.py sync_admissions cohorts","title":"Sync cohorts"},{"location":"apps/admissions/#sync-students","text":"python manage.py sync_admissions students --limit=3 Limit: the number of students to sync","title":"Sync students"},{"location":"apps/monitoring/","text":"Monitor App This app is ideal for running diagnostic and reminders on the breathecode platform. Installation Setup a the monitor app job for once a day, this is the command: $ python manage.py monitor apps Setup a the monitor script job for once a day, this is the command: $ python manage.py monitor script","title":"Monitor App"},{"location":"apps/monitoring/#monitor-app","text":"This app is ideal for running diagnostic and reminders on the breathecode platform.","title":"Monitor App"},{"location":"apps/monitoring/#installation","text":"Setup a the monitor app job for once a day, this is the command: $ python manage.py monitor apps Setup a the monitor script job for once a day, this is the command: $ python manage.py monitor script","title":"Installation"},{"location":"django/SIGNALS/","text":"About Django Signals Source: https://thetldr.tech/how-to-add-custom-signals-dispatch-in-django/ Lets take an example app named, application. So we should create a signals.py file in the path application/signals.py with the following content # application/signals.py from django import dispatch some_task_done = dispatch.Signal(providing_args=[\"task_id\"]) Here we are creating a custom signal some_task_done which can be imported by any application and called. Once we have a signal, lets create an use case, i.e. let us call it. For example let us have a tasks.py file which calls the signal. Any other application can also import the signals and then call it. # application/tasks.py from application import signals def do_some_task(): # did some thing signals.some_task_done.send(sender='abc_task_done', task_id=123) # Here sender can be anything, same are the arguments. So we have seen how to create a signal and how to call it. But we have not seen what happens if we call a signal. This is the most tricky and important part. Whenever we fire a signal, we need some receiver to listen to the signal and perform some action. For this we need to create a receivers.py file (file name can be anything, but try to keep this as a convention for better readability). # application/receivers.py from django.dispatch import receiver from application import signals @receiver(signals.some_task_done) def my_task_done(sender, task_id, **kwargs): print(sender, task_id) # prints 'abc_task_done', 123 Here the receiver decorator is subscribing to the some_task_done signal and whenever the signal would be dispatched then receiver my_task_done function would be called. Now comes the most important part. This is something many people miss which makes signals complicated. Make sure to import the receivers in your apps.py this is important since we need to tell django to load the receivers when app is ready, so that it gets linked to the signals framework # application/apps.py from django.apps import AppConfig class ApplicationConfig(AppConfig): name = \"application\" def ready(self): from application import receivers","title":"About Django Signals"},{"location":"django/SIGNALS/#about-django-signals","text":"Source: https://thetldr.tech/how-to-add-custom-signals-dispatch-in-django/ Lets take an example app named, application. So we should create a signals.py file in the path application/signals.py with the following content # application/signals.py from django import dispatch some_task_done = dispatch.Signal(providing_args=[\"task_id\"]) Here we are creating a custom signal some_task_done which can be imported by any application and called. Once we have a signal, lets create an use case, i.e. let us call it. For example let us have a tasks.py file which calls the signal. Any other application can also import the signals and then call it. # application/tasks.py from application import signals def do_some_task(): # did some thing signals.some_task_done.send(sender='abc_task_done', task_id=123) # Here sender can be anything, same are the arguments. So we have seen how to create a signal and how to call it. But we have not seen what happens if we call a signal. This is the most tricky and important part. Whenever we fire a signal, we need some receiver to listen to the signal and perform some action. For this we need to create a receivers.py file (file name can be anything, but try to keep this as a convention for better readability). # application/receivers.py from django.dispatch import receiver from application import signals @receiver(signals.some_task_done) def my_task_done(sender, task_id, **kwargs): print(sender, task_id) # prints 'abc_task_done', 123 Here the receiver decorator is subscribing to the some_task_done signal and whenever the signal would be dispatched then receiver my_task_done function would be called. Now comes the most important part. This is something many people miss which makes signals complicated. Make sure to import the receivers in your apps.py this is important since we need to tell django to load the receivers when app is ready, so that it gets linked to the signals framework # application/apps.py from django.apps import AppConfig class ApplicationConfig(AppConfig): name = \"application\" def ready(self): from application import receivers","title":"About Django Signals"},{"location":"services/google_cloud/function/","text":"Function Function Google Cloud Function handler __init__ ( self , region , project_id , name ) special Google Cloud Function constructor Parameters: Name Type Description Default region str Google Cloud Function region required project_id str Google Cloud Function project id required name str Google Cloud Function name required Source code in breathecode\\services\\google_cloud\\function.py def __init__ ( self , region , project_id , name ): \"\"\"Google Cloud Function constructor Args: region (str): Google Cloud Function region project_id (str): Google Cloud Function project id name (str): Google Cloud Function name \"\"\" resolve_credentials () self . service_url = f ' { region } - { project_id } .cloudfunctions.net/ { name } ' call ( self , data = None ) Call a Google Cloud Function Parameters: Name Type Description Default data dict Arguments of Google Cloud Function None Returns: Type Description Response (dict) Google Cloud Function response Source code in breathecode\\services\\google_cloud\\function.py def call ( self , data = None ): \"\"\"Call a Google Cloud Function Args: data (dict): Arguments of Google Cloud Function Returns: Response (dict): Google Cloud Function response \"\"\" from google.oauth2.id_token import fetch_id_token auth_req = GCRequest () id_token = fetch_id_token ( auth_req , 'https://' + self . service_url ) headers = { 'Authorization' : f 'Bearer { id_token } ' } if data : headers [ 'Content-Type' ] = 'application/json' headers [ 'Accept' ] = 'application/json' data = json . dumps ( data ) request = requests . post ( 'https://' + self . service_url , data = data , headers = headers ) logger . info ( f 'Cloud function { self . service_url } ' ) logger . info ( request . content . decode ( 'utf-8' )) res = request . json () return res","title":"Function"},{"location":"services/google_cloud/function/#function","text":"","title":"Function"},{"location":"services/google_cloud/function/#breathecode.services.google_cloud.function.Function","text":"Google Cloud Function handler","title":"Function"},{"location":"services/google_cloud/function/#breathecode.services.google_cloud.function.Function.__init__","text":"Google Cloud Function constructor Parameters: Name Type Description Default region str Google Cloud Function region required project_id str Google Cloud Function project id required name str Google Cloud Function name required Source code in breathecode\\services\\google_cloud\\function.py def __init__ ( self , region , project_id , name ): \"\"\"Google Cloud Function constructor Args: region (str): Google Cloud Function region project_id (str): Google Cloud Function project id name (str): Google Cloud Function name \"\"\" resolve_credentials () self . service_url = f ' { region } - { project_id } .cloudfunctions.net/ { name } '","title":"__init__()"},{"location":"services/google_cloud/function/#breathecode.services.google_cloud.function.Function.call","text":"Call a Google Cloud Function Parameters: Name Type Description Default data dict Arguments of Google Cloud Function None Returns: Type Description Response (dict) Google Cloud Function response Source code in breathecode\\services\\google_cloud\\function.py def call ( self , data = None ): \"\"\"Call a Google Cloud Function Args: data (dict): Arguments of Google Cloud Function Returns: Response (dict): Google Cloud Function response \"\"\" from google.oauth2.id_token import fetch_id_token auth_req = GCRequest () id_token = fetch_id_token ( auth_req , 'https://' + self . service_url ) headers = { 'Authorization' : f 'Bearer { id_token } ' } if data : headers [ 'Content-Type' ] = 'application/json' headers [ 'Accept' ] = 'application/json' data = json . dumps ( data ) request = requests . post ( 'https://' + self . service_url , data = data , headers = headers ) logger . info ( f 'Cloud function { self . service_url } ' ) logger . info ( request . content . decode ( 'utf-8' )) res = request . json () return res","title":"call()"},{"location":"services/google_cloud/storage/","text":"Storage Storage Google Cloud Storage file ( self , bucket_name , file_name ) Get File object Parameters: Name Type Description Default bucket_name str Name of bucket in Google Cloud Storage required file_name str Name of blob in Google Cloud Bucket required Returns: Type Description File File object Source code in breathecode\\services\\google_cloud\\storage.py def file ( self , bucket_name : str , file_name : str ): \"\"\"Get File object Args: bucket_name (str): Name of bucket in Google Cloud Storage file_name (str): Name of blob in Google Cloud Bucket Returns: File: File object \"\"\" bucket = self . client . bucket ( bucket_name ) return File ( bucket , file_name )","title":"Storage"},{"location":"services/google_cloud/storage/#storage","text":"","title":"Storage"},{"location":"services/google_cloud/storage/#breathecode.services.google_cloud.storage.Storage","text":"Google Cloud Storage","title":"Storage"},{"location":"services/google_cloud/storage/#breathecode.services.google_cloud.storage.Storage.file","text":"Get File object Parameters: Name Type Description Default bucket_name str Name of bucket in Google Cloud Storage required file_name str Name of blob in Google Cloud Bucket required Returns: Type Description File File object Source code in breathecode\\services\\google_cloud\\storage.py def file ( self , bucket_name : str , file_name : str ): \"\"\"Get File object Args: bucket_name (str): Name of bucket in Google Cloud Storage file_name (str): Name of blob in Google Cloud Bucket Returns: File: File object \"\"\" bucket = self . client . bucket ( bucket_name ) return File ( bucket , file_name )","title":"file()"}]}